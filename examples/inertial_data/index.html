<!doctype html>
<html>
  <head>
    <title>yarp.js Send and Receive Inertial Data</title>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" type="text/css" href="mystyle.css">
    <script src="functions.js" type="text/javascript"></script>
  </head>
  <body>
    <div id='description'>
      <div class='closebutton'>x</div>
      <h1>Send and Receive Inertial Data</h1>
      <p>
        This demo shows how information send on the <b>YARP</b> network can be visualized with tools available in modern browsers. In particular we will use <a target='_blank' href='https://developers.google.com/chart/'>Google Charts</a> and <a target='_blank' href='http://threejs.org/'>Three.js</a> to visualize the current orientation of a device streaming inertial data over the <b>YARP network</b>.
      </p>
      <p>
        You will need <b>two devices</b>: one equipped with inertial sensing capabilities, which will write on the YARP network a 3 dimensional vector containing the device orientation. A second device will read this information from the network and visualized it on screen.
      </p>
      <p>
        On both devices, go to this page. Then on the device supposed to send out inertial data, click on the Send Data button.
      </p>
    </div>
    <div id='send_inertial_data_container' class='cont invisible'>
      <!-- <a id='' class="btn btn-lg disabled">Send Data</a> -->
      <button id='send_inertial_data' type="button" class="btn" data-toggle="button" aria-pressed="false" autocomplete="off">
            Send Data
      </button>
    </div>
    <div id="canvas-container">
      <canvas id="megacanvas"></canvas>
    </div>
    <div id="chart_div"></div>
  </body>
  <script src="/jquery/dist/jquery.min.js"></script>
  <script src="/three/build/three.js"></script>
  <script src="/yarp.js"></script>
  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

  <script>
    var socket = io();
    yarp.init(socket);

    // what to do as soon as the yarp module is ready
    yarp.onInit(function() {

      var sending_inertial_data = false;

      var port_orientation_out = yarp.PortHandler.openPort('/yarpjs/device/orientation:o');
      var port_acceleration_out = yarp.PortHandler.openPort('/yarpjs/device/acceleration:o');

      var port_orientation_in = yarp.PortHandler.openPort('/yarpjs/device/orientation:i');
      var port_acceleration_in = yarp.PortHandler.openPort('/yarpjs/device/acceleration:i');

      port_orientation_in.onRead(function(bottle){

        var orientation = bottle.content;

        drawData(orientation);

        if(!sending_inertial_data)
          chartData(orientation);
      });

      yarp.Network.connect('/yarpjs/device/orientation:o','/yarpjs/device/orientation:i');
      yarp.Network.connect('/yarpjs/device/acceleration:o','/yarpjs/device/acceleration:i');

      var send_inertial_data_btn = document.getElementById('send_inertial_data');

      var orientation_listener_initialized = false;

      if (window.DeviceOrientationEvent) {

          function detect_deviceorientation() {

            if( !orientation_listener_initialized )
            {
              if(event.alpha == null || event.beta == null || event.gamma==null)
                return;
              window.removeEventListener("deviceorientation", detect_deviceorientation);
              document.getElementById('send_inertial_data_container').classList.remove('invisible');

              orientation_listener_initialized = true;
            }
          }
          window.addEventListener("deviceorientation", detect_deviceorientation, true);
          window.addEventListener("deviceorientation", function send_deviceorientation () {

            if( sending_inertial_data )
            {

              var alpha = event.alpha;
              var beta = event.beta;
              var gamma = event.gamma;

              // setTimeout(function(){
                port_orientation_out.write([alpha,beta,gamma]);
              // },1);

            }
          }, true );

          window.addEventListener('devicemotion', function send_devicemotion() {
            if( sending_inertial_data )
            {
              var x = event.acceleration.x;
              var y = event.acceleration.y;
              var z = event.acceleration.z;
              // setTimeout(function(){
                port_acceleration_out.write([x,y,z]);
              // },1);
            }
          }, true );
          send_inertial_data_btn.onclick = function toggle_sending() {
            //close the ports but only locally
            // port_orientation_in.close(true);
            // port_acceleration_in.close(true);
            send_inertial_data_btn.classList.toggle('btn-primary');
            sending_inertial_data = !sending_inertial_data;
          }
      }
    });

//  <!-- Google Charts -->

    google.charts.load('current', {packages: ['corechart', 'line']});
    google.charts.setOnLoadCallback(_initData);

//
    var chart = undefined;
    var data = undefined;
    var data_view = undefined;

    var options = {
      hAxis: {
        title: 'Time'
      },
      vAxis: {
        title: 'Angle'
      },
      colors: ['#a52714', '#097138','#53A757']
    };

//
    var max_length = 30;
    var curr_idx = 0;

    var datum;

    _chartData();

//  <!-- Garden demo from: https://developer.mozilla.org/en-US/docs/Web/API/Detecting_device_orientation -->

    // var ball   = document.querySelector('.ball');
    // var garden = document.querySelector('.garden');
    // var output = document.querySelector('.output');

    // var maxX = garden.clientWidth  - ball.clientWidth;
    // var maxY = garden.clientHeight - ball.clientHeight;

    // function handleOrientation(orientation) {
    //   var x = orientation[1];  // In degree in the range [-180,180]
    //   var y = orientation[2]; // In degree in the range [-90,90]
    //   var z = orientation[0]; // In degree in the range [-90,90]

    //   output.innerHTML  = "alpha : "  + z + "\n";
    //   output.innerHTML += "beta : "   + x + "\n";
    //   output.innerHTML += "gamma: "   + y + "\n";

    //   // Because we don't want to have the device upside down
    //   // We constrain the x value to the range [-90,90]
    //   if (x >  90) { x =  90};
    //   if (x < -90) { x = -90};

    //   // To make computation easier we shift the range of
    //   // x and y to [0,180]
    //   x += 90;
    //   y += 90;

    //   // 10 is half the size of the ball
    //   // It center the positioning point to the center of the ball
    //   ball.style.top  = (maxX*x/180 - 10) + "px";
    //   ball.style.left = (maxY*y/180 - 10) + "px";
    // }


  //<!-- Three.js -->

      var autoAlign = true;
      var alignQuaternion = new THREE.Quaternion();
      var orientationQuaternion = new THREE.Quaternion();

      var quaternion = new THREE.Quaternion();
      var quaternionLerp = new THREE.Quaternion();

      var tempVector3 = new THREE.Vector3();
      var tempMatrix4 = new THREE.Matrix4();
      var tempEuler = new THREE.Euler(0, 0, 0, 'YXZ');
      var tempQuaternion = new THREE.Quaternion();

      var zee = new THREE.Vector3(0, 0, 1);
      var up = new THREE.Vector3(0, 1, 0);
      var v0 = new THREE.Vector3(0, 0, 0);
      var euler = new THREE.Euler();
      var q0 = new THREE.Quaternion(); // - PI/2 around the x-axis
      var q1 = new THREE.Quaternion(- Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));


      var scene, camera, renderer, controls;
      var cellphone, material;

      init();
      animate();

//
    var description_object = document.getElementById('description');
    description_object.getElementsByClassName('closebutton')[0].onclick = function closeDescription() {
      description_object.classList.add('invisible');
    }
    var route_parameters = location.search.substring(1).split("&");

    var description_visible = false;
    for(var route_idx=0; route_idx<route_parameters.length; route_idx++)
    {
      var route_tmp = route_parameters[0].split("=");
      if(route_tmp[0] == 'description' && !(!unescape(route_tmp[1])) == true)
      {
        description_visible = true;
      }
    }
    if(!description_visible)
    {
      description_object.classList.add('invisible');
    }
  </script>
</html>
